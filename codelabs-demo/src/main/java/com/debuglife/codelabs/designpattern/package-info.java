/**
 * 大家都说设计模式可根据目的划分为：
 * 1、创建型（creational）：主要用于处理对象的创建，实例化对象
 * 2、结构型（structural）：处理类或对象间的组合
 * 3、行为型（behavioral）：描述类或对象怎样进行交互和职责分配
 * 但是让我疑问的是，为什么大家都约定俗成的把n个设计模式分门别类到这三个类别中去呢？分类的具体依据呢？创建型就真的用来创建对象？结构型就组合对象吗？它是怎么创建怎么组合的呢？
 * 带着这些问题，笔者再度整理了一下思绪，提出几个特征明显的给您娓娓道来~至于针对每一类模式的进一步总结，敬请期待接下来的博文。
 * 
 * 创建型：
 * 1、简单工厂（本不属于经典模式，列此尽供对比参考）：创建一个工厂，通过增加分支语句的方式来增加创建新的对象。
 * 2、工厂方法模式：通过定义一个创建对象的接口来对类进行实例化。不用再对客户端代码进行修改，增加新的实例化。
 * 3、抽象工厂模式：通过定义一系列创建对象的接口来对创建对象。当类和操作类不断增多，不止一个时，单纯的创建一个接口实例化对象（工厂方法模式）已经不足以解决问题。这时便需要在此基础之上，创建一系列接口用于实例化，便可不用指定具体实例化那哪一个类。
 * 4、单例模式：遵循“计划生育”政策，防止超生，单例模式保证让一个类仅拥有一个实例。便可保证只有这一个实例可以被创建，被访问。
 * 5、建造者模式：保证在创建对象时，将产品的内部组成与生成过程隔离开来，使用同样的创建过程便可以创建出胖瘦不同的对象。
 * 6、原型模式：利用原型实例来“克隆”创建新的对象。
 * 
 * 结构型：
 * 1、装饰模式：系统需要新的功能时，避免在主类中添加新字段，把某些特殊的功能（装饰物）选择性的单独放到一个类中。这就属于类与类之间的组合结构，怎么组合，那种装饰方式。故属于结构型模式。
 * 2、适配器模式：姚明在NBA需要翻译，老外来中国也需要翻译。将一个类的接口转换成另一个希望的接口，适配器的作用即在此。 
 * 
 * 行为型：
 * 1、观察者模式：当几个对象之间，一个改变需要同时改变多个对象时，利用观察者模式解除耦合，让耦合双方都依赖于抽象。就像老板回来了，偷懒的同事应该依赖的是前台秘书这个抽象类，而不应依赖于具体的名为“小白”的秘书。这都是针对于对象间不同行为的职责分配而使用的模式。
 * 看到这里，写到这里，貌似巨人们对设计模式进行这样的分类确实是有实际依据的。疑惑的问号也可稍稍远行些了。以上仅为三类模式中部分典型代表，具体各类模式总结，详见下回分解，敬请期待。
 */

package com.debuglife.codelabs.designpattern;